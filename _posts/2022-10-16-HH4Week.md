---
layout: single
title: "4주차 과제"
comments: true
description: "라이프사이클(클래스형 vs 함수형), react hooks"
categories: "React"
tag: ["react", "hooks"]
toc: true
author_profile: false
published: true
sidebar:
  nav: "docs"
---

<br/> <br/> <br/>
라이프사이클(클래스형 vs 함수형), react hooks
&nbsp; 리액트 컴포넌트의 라이프 사이클과 hook에 대해 살펴보자

### life cycle

&nbsp;리액트는 천방지축으로 날뛰는 DOM을 개발자가 예상가능한 방식으로 통제할 수 있게 도와준다.
원래의 웹은 다음과 같은 방식으로 페이지가 변경되었다. <br/>

- 유저가 이벤트를 발생 시킴
- 핸들러 동작
- DOM을 직접 변경

<br/>
&nbsp; 물론 실제로는 더 복잡한 과정들이 많이 추가 되겠지만 브라우져를 변경하는 상황만 살펴봤을 때를 의미한다. <br/>
&nbsp; 반면 리액트는 개발자가 DOM의 특정부분에 대해 완전하게 통제를 할 수 있게 된다. 리액트를 사용한다고 DOM의 모든 요소를 하나하나 개발자가 통제한다는 의미는 아니지만, 적어도 완벽하게 통제할 대상을 지정 할 수 가 있다. 또한 반대로 전혀 통제하지 않고 그냥 유저가 변경하는 대로 결사코 관심을 두지 않는 부분도 지정할 수 가 있다. <br/>
&nbsp; 관심을 두는 데이터가 변경되면 해당 데이터와 연관된 모든 컴포넌트와 그 컴포넌트의 모든 하위 컴포넌트에 렌더링이 일어난다. 렌더링이 일어난다는 것과 브라우져에 보여지는 화면을 다시 그리는 것은 같은 뜻은 아니다. 논리적으로 보자면 렌더링이 일어나는 것은 화면을 다시 그리기 위한 필요조건이다. <br/>
&nbsp; 리액트에서 중요한 것은 컴포넌트이 관심사이다. 관심사는 state로 표현되며 [공식문서](https://beta.reactjs.org/learn/state-a-components-memory)에는 component가 가지고 있는 memory라고 말한다.

> Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state.

&nbsp; 컴포넌트가 해당 값을 기억해두고 오직 해당 값이 변경될 때만 렌더링을 발생시킨다. 랜더링의 결과물로 VirtualDOM이 생성되고 이전의 VirtualDOM과 비교하여 변경된 부분을 찾는다. 그리고 변경되었다면 변경된 결과만 DOM에 반영한다.<br/>
&nbsp; 이러한 과정중 가장 핵심이 바로 컴포넌트의 랜더링이라고 할 수가 있다. 요즘은 대부분 리액트를 함수형으로 쓰고 본인도 개발경험이 많지않아 컴포넌트형으로 리액트 앱을 만들어 본 적이 거의 없다. 다만, 컴포넌트 형으로 쓰게 되면 라이프사이클 함수를 직접 불러와 사용하기에 컴포넌트의 랜더링, 재랜더링 과정에 대해 좀 더 손에 와닿는 이해를 할 수 있을 것 이라고 생각한다.<br/>
&nbsp; 컴포넌트의 라이프 사이클은 크게 세가지 경우라고 볼 수 있다. 생성, 변경, 제거이며, 리액트스러운 용어로 쓰자면 mount, update, unmount 라고 할 수 있다. mount는 컴포넌트를 생성하고 화면상에 최초로 보여지게 만드는 것이고 unmount는 화면상에서 제거하는 것을 의미한다. 최초의 랜더링이 일어났다면 (컴포넌트를 생성하는 함수를 호출했다면) mount가 됐다고 볼 수 있다. 반대로 mount되었던 컴포넌트가 유저가 작동시킨 이벤트 핸들러의 결과로 더 이상 렌더링이 되지 않는다면, 해당 컴포넌트는 unmount된다.<br/>
&nbsp; update는 이미 mount된 컴포넌트를 다시 한번 랜더링 했을때 (함수를 다시 호출했을 때) 발생한다. 정확히는 발생할 가능성이 생긴다. 앞서 말했듯 랜더링은 update의 필요조건이기 때문이다. 리랜더링은 다음 네가지 상황에서 발생한다.

- props가 바뀔 때
- state가 바뀔 때
- 부모 컴포넌트가 리렌더링 될 때
- this.forceUpdate로 강제로 리렌더링 할 때

[참고 - kyun2da.dev](https://kyun2da.dev/react/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4%EC%9D%98-%EC%9D%B4%ED%95%B4/)
<br/> <br/>

### update 시 class 형의 라이프사이클

- getDerivedStateFromProps ([참고 - react 공식문서](https://ko.reactjs.org/docs/react-component.html#static-getderivedstatefromprops))
  - props 변화에 대응한 부수 효과를 발생시켜야 한다면 (예를 들어, 데이터 가져오기 또는 애니메이션), componentDidUpdate 생명주기를 대신해서 사용하세요.
  - props가 변화했을 때에만 일부 데이터를 다시 계산 하고 싶다면, Memoization Helper를 대신해서 사용하세요.
  - props가 변화할 때에 일부 state를 재설정 하고 싶다면, 완전 제어 컴포넌트 또는 key를 사용하는 완전 비제어 컴포넌트로 만들어서 사용하세요.
- shouldComponentUpdate
  - 성능최적화를 위한 메서드이며 다른 용도로 사용하는 경우 예상치 못한 오류가 발생할 수 있다.
  - 함수형에서는 React.memo를 사용하여 구현할수 있다.
- render
  - 컴포넌트를 렌더링할 때 필요한 메서드로 유일한 필수 메서드이기도 하다. 함수형 컴포넌트에서는 render를 안쓰고 컴포넌트를 렌더링할 수 있다.
- getSnapshotBeforeUpdate
  - render에서 만들어진 결과가 브라우저에 실제로 반영되기 직전에 호출된다.
- ComponentDidUpdate
  - 업데이트가 완료된 이후 실행된다.
  - 함수 형의 경우 useEffect 훅을 활용하여 구현 가능하다.
<br/> 
&nbsp; 

### react hooks
<br/> 
&nbsp; 리액트의 가장 큰 장점은 어떤 값을 관심사로 둘지의 여부를 개발자가 선택할 수 있다는 점이다. `use` 라는 키워드를 접두어를 사용하여 함수를 만들면 컴포넌트 내부에서 사용했을 때 컴포넌트와 후킹이 되어 컴포넌트 종속적인 데이터로 지정할 수 있다. 장점은 해당 컴포넌트와 생명주기를 공유하게 되어 예상치못한 오류를 방지할 수 있다는 점이 가장 크다고 생각한다.
